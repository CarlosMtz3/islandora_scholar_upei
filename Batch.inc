<?php

/**
 * @file
 * 
 * Collection of functions related to Batch ingests.
 */
/**
 * Performs a bulk ingestion.
 * 
 * This is not meant to be called from drupal_get_form, 
 * this is a sub-form that part of the content_model_viewer_ingest_metadata
 * 
 * @param array $form_state
 *   The Drupal form state.
 * @param string $collection_pid 
 *   The pid of the collection we will ingest into.
 * 
 * @return array
 *   The Drupal form.
 */
//function scholar_bulk_ingest_form(array &$form_state, $collection_pid) {
//  $potential_models = scholar_bulk_ingest_get_potential_models($collection_pid);
//  reset($potential_models);
//  $identifier = key($potential_models);
//  $name = current($potential_models);
//  $selected_model = isset($form_state['values']['models']) ? $form_state['values']['models'] : $identifier;
//  $form = array(
//    'bulk_ingest' => array(
//      '#type' => 'fieldset',
//      '#title' => t('Ingest digital objects generated by RIS/EndNote into collection_pid Step #1', array('collection_pid' => $collection_pid)),
//      'file' => array(
//        '#type' => 'file',
//        '#title' => t('Upload "RIS" or "EndNote XML" Document'),
//        '#description' => t('A RIS or EndNote XML document that will generate multiple digital objects on ingest. One for each record within the RIS or EndNote XML document.'),
//        '#element_validate' => array('scholar_bulk_ingest_file_upload_validate'),
//      ),
//      'content_model_pid' => array(
//        '#type' => 'select',
//        '#title' => t('Content models available'),
//        '#options' => $potential_models,
//        '#default_value' => $selected_model,
//        '#description' => t('Content models define datastream composition, relationships between this and other content models, and the mandatory behaviors associated with each digital object.<br /> Additional information may be found <a href="https://wiki.duraspace.org/display/FEDORACREATE/Content+Models+Overview">here.</a> '),
//      ),
//      'submit' => array(
//        '#type' => 'submit',
//        '#executes_submit_callback' => TRUE,
//        '#submit' => array('scholar_bulk_ingest_form_submit'),
//        '#value' => t('Ingest')
//      ),
//    )
//  );
//  return $form;
//}
//
///**
// * Get Potential Models that can be part of the given collection.
// * 
// * @param string $collection_pid
// *   The pid of the collection.
// * @return array
// *   Where the key is the Content Model PID and the value is the human readable name for the Content Model.
// */
//function scholar_bulk_ingest_get_potential_models($collection_pid) {
//  if (($collection_policy = CollectionPolicy::loadFromCollection($collection_pid)) === FALSE) {
//    drupal_set_message(t('Unable to load collection policy \'' . $collection_pid . '\'.'));
//    return FALSE;
//  }
//  if (!($content_models = $collection_policy->getContentModels())) {
//    drupal_set_message(t('No content models associated with this collection: !collection_pid. Please contact your administrator.', array('!collection_pid' => $collection_pid)), 'error');
//    return FALSE;
//  }
//  $potential_models = array();
//  foreach ($content_models as $content_model) {
//    $identifier = $content_model->getIdentifier();
//    $name = $content_model->name;
//    $potential_models["$identifier"] = "$name";
//  }
//  return $potential_models;
//}
//
///**
// * Over writes the default 'content_model_viewer_ingest_metadata_form_validate' function.
// * 
// * @param array $form
// *   The Drupal form.
// * @param array $form_state 
// *   The Drupal form state.
// */
//function scholar_bulk_ingest_form_validate(array &$form, array &$form_state) {
//  drupal_set_message(t('Validating...'));
//  $bulk_ingest_clicked = $form_state['clicked_button']['#value'] == t('Ingest');
//  if (!$bulk_ingest_clicked) {
//    if ($form_state['storage']['step'] == 1) {
//      $form_state['storage']['step']++;
//      $form_state['rebuild'] = TRUE;
//    }
//    else {
//      module_load_include('inc', 'xml_form_api', 'XMLForm');
//      $xml_form = new XMLForm($form_state);
//      $xml_form->validate($form, $form_state);
//    }
//  }
//}
//
///**
// * Makes sure the file was uploaded and is of the right type.
// * 
// * @param array $element
// *   The file upload field
// * @param array $form_state 
// *   The Drupal form state.
// */
//function scholar_bulk_ingest_file_upload_validate(array $element, array &$form_state) {
//   drupal_set_message(t('Validating file...'));
//  $bulk_ingest_clicked = $form_state['clicked_button']['#value'] == t('Ingest');
//  $file_uploaded = isset($_FILES['files']['error']['file']) && $_FILES['files']['error']['file'] == 0;
//  if ($bulk_ingest_clicked) {
//    if (!$file_uploaded) {
//      form_error($element, t('You must upload a "RIS" or "EndNote XML" document.'));
//    }
//    else { // Only support for one file.
//      $mime_type = $_FILES['files']['type']['file'];
//      $valid_types = array('text/xml', 'text/plain', 'application/x-research-info-systems');
//      if (array_search($mime_type, $valid_types) === FALSE) {
//        form_error($element, t('The upload file is not the correct type. You must upload a "RIS" or "EndNote XML" document.'));
//      }
//    }
//  }
//}
//
///**
// * Bulk Ingest object.
// * 
// * @param array $form
// *   The Drupal form.
// * @param array $form_state 
// *   The Drupal form state.
// */
//function scholar_bulk_ingest_form_submit(array &$form, array &$form_state) {
//   drupal_set_message(t('Submitting form...'));
//  $collection_pid = $form_state['values']['collection_pid'];
//  $content_model_pid = ContentModel::getPidFromIdentifier($form_state['values']['content_model_pid']);
//  $mime_type = $_FILES['files']['type']['file'];
//  $file = file_save_upload('file');
//  $filename = $file->filepath;
//  $function = ($mime_type == 'text/xml') ? 'scholar_batch_ingest_endnote_document' : 'scholar_batch_ingest_ris_document';
//  $operations = array(
//    array($function, array($filename, $collection_pid, $content_model_pid))
//  );
//  $batch = array(
//    'title' => t('Ingesting Files'),
//    'operations' => $operations,
//    'file' => drupal_get_path('module', 'scholar') . '/Batch.inc',
//  );
//  batch_set($batch);
//  unset($form_state['storage']); // Return to the viewer.  
//}

/**
 * Ingests multiple objects one for each record within the given EndNote XML document.
 * 
 * @param string $filename
 *   The name of the EndNote XML file to ingest.
 * @param type $collection_pid
 *   The pid of the collection to ingest into.
 * @param type $content_model_pid
 *   The content model to assign to the new pid.
 * @param array $context 
 *   The drupal batch context.
 */
function scholar_batch_ingest_endnote_document($filename, $collection_pid, $content_model_pid, array &$context) {
  module_load_include('inc', 'bibutils', 'Batch');
  module_load_include('inc', 'bibutils', 'Bibutils');
  if (empty($context['sandbox'])) {
    $context['sandbox']['progress'] = 0;
    $context['sandbox']['total'] = bibutils_batch_get_number_endnote_records($filename);
  }
  $temp_file_dir = file_directory_path(); // Changed the temp dir so that the files can be accessed
  //these filenames should be generated somehow as right now if multiple users
  //tried to do a batch ingest they would be stepping on each other.
  $mods_filename = file_create_filename('mods.xml', $temp_file_dir);
  $endnote_filename = file_create_filename('endnote.xml', $temp_file_dir);
  $record = bibutils_batch_get_endnote_record($filename); // Get Single EndNote XML Record
  $record->save($endnote_filename);
  if (Bibutils::Convert($endnote_filename, 'EndNoteXML', $mods_filename, 'MODS')) {
    Bibutils::CleanModsFile($mods_filename);
    $endnote_url = file_directory_path() . '/endnote.xml';
    scholar_batch_ingest_mods($mods_filename, $collection_pid, $content_model_pid, array('ENDNOTE' => $endnote_url));
  }
  unlink($mods_filename);
  $context['sandbox']['progress']++;
  if ($context['sandbox']['progress'] != $context['sandbox']['total']) {
    $context['finished'] = $context['sandbox']['progress'] / $context['sandbox']['total'];
  }
}

/**
 * takes a refworks xml file with multiple reference elements and creates 
 * a new fedora object for each reference.
 * 
 * @param string $filename
 * @param string $collection_pid
 * @param string $content_model_pid
 * @param array $context 
 */
function scholar_batch_ingest_refworks_document($filename, $collection_pid, $content_model_pid, array &$context) {
  $doc = new DOMDocument();
  $xml = file_get_contents($filename);
  static $file_list = array();
  $xml = trim($xml); //refworks has a nasty habit of outputing an xml file with 
  // the xml declartion being the second line, the first line being blank
  $success = $doc->loadXML($xml);
  $root = $doc->documentElement;
  $nodeName = $root->nodeName;
  if (!$success || !$nodeName == 'refworks') {
    drupal_set_message(t('error doing refworks batch ingest'));
    return;
  }
  $references = $doc->getElementsByTagName('reference');
  $count = $references->length;

  if (empty($context['sandbox'])) {
    $context['sandbox']['progress'] = 0;
    $context['sandbox']['total'] = $count;
  }

  $reference = $references->item($context['sandbox']['progress']);
  $title = $reference->getElementsByTagName('t1');
  $title_text = $title->item(0)->nodeValue;
  $context['message'] = t('Added %title', array('%title' => $title_text));
  $rxml = $doc->saveXML($reference);
  $mods = scholar_batch_ingest_mods_from_refworks($reference, $rxml);
  $refworks_filename = file_create_filename(scholar_batch_create_filename('Refworks_','.xml')
      ,file_directory_path());
  $mods_filename = file_create_filename(scholar_batch_create_filename('sm_','.xml')
      ,file_directory_path());
  $policy_filename = file_create_filename(scholar_batch_create_filename('POLICY_','.xml')
      ,file_directory_path());
  module_load_include('inc', 'islandora_xacml_api', 'Xacml');
  $xacml = new Xacml();
  scholar_batch_add_xacml_users_and_roles($reference, $xacml);
  $xacml_string = $xacml->getXmlString();
  file_put_contents($policy_filename, $xacml_string);
  file_put_contents($mods_filename, $mods);
  file_put_contents($refworks_filename, $rxml);
  scholar_batch_ingest_mods($mods_filename, $collection_pid, $content_model_pid
      , array('refworks' => $refworks_filename,
    'POLICY' => $policy_filename));
  $context['sandbox']['progress']++;
  if ($context['sandbox']['progress'] != $context['sandbox']['total']) {
    $context['finished'] = $context['sandbox']['progress'] / $context['sandbox']['total'];
  }
  else {
    unlink($filename);
  }
}

/**
 * adds the appropriate users and roles to an xacml policy
 * 
 * @param DOMElement $reference
 * @param XACML object $xacml 
 */
function scholar_batch_add_xacml_users_and_roles($reference, &$xacml) {
  $users = $reference->getElementsByTagName('u1');
  $roles = $reference->getElementsByTagName('u2');
  foreach ($users as $user) {
    $us = explode(';', $user->nodeValue);
    foreach ($us as $u) {
      $xacml->managementRule->addUser($u);
    }
  }
  foreach ($roles as $role) {
    $rs = explode(';', $role->nodeValue);
    foreach ($rs as $r) {
      $xacml->managementRule->addRole($r);
    }
  }
}

/**
 *
 * @global object $user
 *  drupal user object
 * @param string $prefix
 *   filename prefix
 * @param string $suffix
 *   filename suffix
 * @return string 
 *   a unique filename
 */
function scholar_batch_create_filename($prefix="",$suffix="") {
  global $user;
  return $prefix . md5(uniqid($user->uid. rand(), TRUE)).$suffix;
}

/**
 *
 * @param DOMElement $reference
 * @param string $rxml
 *   refworks xml
 * @return xml
 *   a mods xml file 
 */
function scholar_batch_ingest_mods_from_refworks($reference, $rxml) {
  $genre = $reference->getElementsByTagName('rt');
  $genre_text = $genre->item(0)->nodeValue;
  $path = drupal_get_path('module', 'scholar');
  $xslt_path = NULL;
  switch ($genre_text) {
    case 'Book, Section':
      $xslt_path = $path . '/xsl/refworks_to_mods_book_section.xsl';
      break;
    case 'Book, Whole':
    case 'Sound Recording':
    case 'Dissertation/Thesis':
    case 'Dissertation/Thesis, Unpublished':
      $xslt_path = $path . '/xsl/refworks_to_mods_book.xsl';
      break;
    case 'Conference Proceedings':
      $xslt_path = $path . '/xsl/refworks_to_mods_conf.xsl';
      break;
    default:
      $xslt_path = $path . '/xsl/refworks_to_mods_journal.xsl';
  }
  $rdoc = new DOMDocument();
  $xslt = new XSLTProcessor();
  $rdoc->loadXML($rxml);
  $xslt_doc = new DOMDocument();
  $xslt_doc->load($xslt_path);
  $xslt->importStylesheet($xslt_doc);
  $mods = $xslt->transformToXml($rdoc);
  return $mods;
}

/**
 * Batch ingest the RIS document.
 * 
 * @param string $filename
 *   The name of the EndNote XML file to ingest.
 * @param type $collection_pid
 *   The pid of the collection to ingest into.
 * @param type $content_model_pid
 *   The content model to assign to the new pid.
 * @param array $context 
 *   The drupal batch context.
 */
function scholar_batch_ingest_ris_document($filename, $collection_pid, $content_model_pid, array &$context) {
  module_load_include('inc', 'bibutils', 'Batch');
  module_load_include('inc', 'bibutils', 'Bibutils');
// This code removes ^M characters that are present in exported Refworks files
// which don't show up as new lines in linux.
  $initial_ris = file_get_contents($filename);
  $cleaned_ris = str_replace("\x0D", "\n", trim($initial_ris));
  $initial_file = fopen($filename, 'w');
  fwrite($initial_file, $cleaned_ris);
  fclose($initial_file);

  if (empty($context['sandbox'])) {
    $context['sandbox']['progress'] = 0;
    $context['sandbox']['total'] = bibutils_batch_get_number_ris_records($filename);
  }

  $temp_file_dir = file_directory_path(); // Changed the temp dir so that the files can be accessed
  $mods_filename = file_create_filename('mods.xml', $temp_file_dir);
  $ris_filename = file_create_filename('ris.txt', $temp_file_dir);
  $record = bibutils_batch_get_ris_record($filename); // Get Single RIS Record
  $file = fopen($ris_filename, 'w');
  fwrite($file, $record);
  fclose($file);

  if (Bibutils::Convert($ris_filename, 'RIS', $mods_filename, 'MODS')) {
    $ris_url = file_directory_path() . '/ris.txt';
    scholar_batch_ingest_mods($mods_filename, $collection_pid, $content_model_pid, array('RIS' => $ris_url));
  }
// Remove the files.
  unlink($ris_filename);
  unlink($mods_filename);
  $context['sandbox']['progress']++;
  if ($context['sandbox']['progress'] != $context['sandbox']['total'] && $context['sandbox']['total'] != 0) {
    $context['finished'] = $context['sandbox']['progress'] / $context['sandbox']['total'];
  }
}

/**
 * todo add comments
 * 
 * @param string $filename
 * @param string $collection_pid
 * @param string $content_model_pid
 * @param array $datastreams 
 */
function scholar_batch_ingest_mods($filename, $collection_pid, $content_model_pid, $datastreams) {
  module_load_include('inc', 'islandora_content_model_forms', 'FOXML');
  module_load_include('inc', 'fedora_repository', 'CollectionPolicy');
  $collection_policy = CollectionPolicy::loadFromCollection($collection_pid);
  if ($collection_policy !== FALSE) {
    $document = new DOMDocument();
    $document->load($filename);
    $label = scholar_batch_ingest_mods_guess_title($document); // Find a best guess solution... to pull from the mods.
    $pid = $collection_policy->getNextPid('ISLANDORACM');
    $dsid = 'MODS';
    $relationship = $collection_policy->getRelationship();
    $ingest_file_location = $datastreams;
    $transform = drupal_get_path('module', 'scholar') . '/xsl/mods_to_dc.xsl';
    $state = 'A';
    $foxml = new FOXML($label, $pid, $dsid, $content_model_pid, $collection_pid, $relationship, $ingest_file_location, $document, $transform, $state);
    $foxml->ingest();
    unlink($filename);//the batch ingest functions removes the policy and refworks files but not the mods
  }
}

/**
 * Guess the title for the object generated from mods.
 * 
 * @param DOMDocument $mods
 *   The MODS document in which to extract the title from.
 * 
 * @return string
 *   The extracted title or a default title.
 */
function scholar_batch_ingest_mods_guess_title(DOMDocument $mods) {
  $default_title = t('Default Title (Please Correct)');
  $xpath = new DOMXPath($mods);
  $xpath->registerNamespace('mods', 'http://www.loc.gov/mods/v3');
  $results = $xpath->query('/mods:mods/mods:titleInfo[not(@type)]/mods:title[1]'); // Ingnore extras.
  if ($results->length == 1) {
    $title = $results->item(0);
    return $title->textContent;
  }
  $results = $xpath->query('/mods:mods/mods:titleInfo/mods:title[1]'); // Ingnore extras, can be abbr or whatever.
  if ($results->length > 0) { // Can be more than one.
    $title = $results->item(0); // Get first
    return $title->textContent;
  }
  return $default_title;
}